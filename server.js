const fs = require('fs');
const path = require('path');
const https = require('https');
const helmet = require('helmet');
const express = require('express');
const passport = require('passport');
const { Strategy } = require('passport-google-oauth20');
const cookieSession = require('cookie-session');

require('dotenv').config();

const PORT = process.env.PORT || 3000;

const config = {
    CLIENT_ID: process.env.CLIENT_ID,
    CLIENT_SECRET: process.env.CLIENT_SECRET,
    COOKIE_KEY_1: process.env.COOKIE_KEY_1,
    COOKIE_KEY_2: process.env.COOKIE_KEY_2
}

const AUTH_OPTIONS = {
    callbackURL: '/auth/google/callback',
    clientID: config.CLIENT_ID,
    clientSecret: config.CLIENT_SECRET
}

// Verify function for google strategy. Checks if the access token/refresh token are valid, then calls done() to supply passport with the authenticated user, or return an error. Since google will be providing tokens, and if it does we know the user is valid, we do not need to use the parameters to be passwords we check ourselves like we would if not using google oauth. We would use this function to check the values against our database somehow if not using oauth.
// When our oauth flow from google completes, we receive the data in these parameters and log it. The object we see in this console.log is what is being used in our serialize and deserialize functions
function verifyCallback(accessToken, refreshToken, profile, done) {
    console.log('Google profile', profile);
    done(null, profile);
}

// Setting up passport to use google's Strategy, taking in an object with the required options for google, and the verify function as parameters
passport.use(new Strategy(AUTH_OPTIONS, verifyCallback))

// Defining a callback to run every time a user is being saved to the cookie to be sent to the browser. Takes in a user object and a done function. Done is a callback used in case we need to do any async work as we serialize the user.
// Save the session to a cookie
passport.serializeUser((user, done) => {
    // null to say there's been no error, pass in the user directly as our cookie value
    // Update to only use the user.id to minimize data flow. When logging the entire user, we were using ~900kb of data, now only ~67kb
    done(null, user.id);
});

// Deserialize is similar. Takes in an object from our session, returns back the data made available inside express through req.user
// Read/load the session data from a cookie. This time only taking in the id we read from the cookie.
passport.deserializeUser((id, done) => {
    // If there is no error, null, return back the object directly. In this case, whatever is coming on from our cookie, is going to be what's populated in this req.user object
    done(null, id);
});

const app = express();

// Keep security middleware at the top, before any routes, so that every request is secured
// Mounting helmet middleware to cover common security vulnerabilities
app.use(helmet());

// We still want helmet to check our headers before we do anything with our sessions, so it goes above our initialization of our sessions. cookieSession can take in options in an object, such as the name of the cookie, and the time before the user has to log in again (maxAge) in milliseconds. The current example will make the session last a day, and can be multiplied further.
// The keys option is how you secure your cookie by listing secret values. This is how the cookie is signed by the server: with this secret key. The server will check that any cookies sent back also use the same key so we know they haven't been tampered with. We set it as an array in case we have to change it; usually it is generated by a password manager. We could add another key to the front of the array, then remove the old one to invalidate it when we're sure all the new sessions are signed by the new key. It's a good idea to always be using 2 keys to sign your session and not hard code them. We'll set them in .env for now.
app.use(cookieSession({
    name: 'session',
    maxAge: 24 * 60 * 60 * 1000,
    keys: [ config.COOKIE_KEY_1, config.COOKIE_KEY_2 ]
}));
// We want our passport initialization to be set up after our cookie session, so passport understands we're using cookie-session
app.use(passport.initialize());
// Authenticates the session being sent to our server using the keys defined above, then sets the req.user value to contain the user's identity. It allows our deserialize function to be called, which sets this property.
app.use(passport.session());

// Creating a function for user authentication and authorization, then running next(); to allow access to the following endpoints if permitted. In express, this or any number of other functions can now be reused and passed in before the req, res handlers in our endpoints to restrict access as needed
function checkLoggedIn(req, res, next) { 
    // Passport session middleware is storing the req, and we can log it here. deserializeUser
    console.log('Current user is:', req.user);
    // If this value exists, then passport has validated the session. Clear cookies for now to verify it works and restricts access to our secret endpoint if we are not logged in.
    const isLoggedIn = req.isAuthenticated(); 
    if (!isLoggedIn) {
        return res.status(401).json({
            error: "You are not logged in"
        });
    }
    next();
}

// Login endpoint. Also using passport's authenticate function, but instead of redirects, we specify the scope property which points to the data we need from google when everything succeeds. Right now, we are just getting the email of our authenticated user
app.get('/auth/google', 
    passport.authenticate('google', {
        scope: ['email']
    }));

// The callback url is what specifies the redirect from our authorization server (Google in this case) when it sends back the authorization code, which is what we use to get back our access token for all of our requests to gain access to restricted data in our application. See Oauth flow diagram for more details. Here we just pass in the passport authenticate function, specifying we are using google, as our callback, the second parameter is an object which specifies what to do on success/failure, with redirects. Sessions are also handled here.
app.get('/auth/google/callback', 
    passport.authenticate('google', {
        failureRedirect: '/failure',
        successRedirect: '/',
        session: true
    }), 
    (req, res) => {
    console.log('Received response from google');
    }
);

// Logout endpoint, logging out doesn't require the user to pass in any data; it will be the same for any provider
app.get('/auth/logout', (req, res) => {
    // Clears our req.user and session data and redirects to the root endpoint
    req.logout();
    res.redirect('/');
});

// Secret endpoint to test authentication/authorization
app.get('/secret', checkLoggedIn, (req, res) => {
    return res.send('Your secret talent is magic.');
});

// If the user fails to login
app.get('/failure', (req, res) => {
    return res.send('Failed to login, or invalid login credentials');
})

// Root & homepage html
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// Creating and listening to our server
https.createServer({
    key: fs.readFileSync('key.pem'),
    cert: fs.readFileSync('cert.pem')
}, app).listen(PORT, () => {
    console.log(`Server is listening on port ${PORT}`);
});

// TO MAKE A CERT: openssl req -x509 -newkey rsa:4096 -nodes -keyout key.pem -out cert.pem 
// For local certs, just leave everything blank, set common name to your name you want to use